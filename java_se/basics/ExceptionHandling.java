package basics;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * Exceptions are errors that affect the flow of a program. Exception Handling
 * is a mechanism to handle such exceptions.
 * 
 * Exception Handling, Try-Catch-FInally blocks, Try-with-Resources.
 */
@SuppressWarnings("resource")
public class ExceptionHandling {

	/*
	 * The JRE library has both an Exception class and a Error class. In Java, an
	 * error refers to a lower-level error (such as VM error, memory issues, etc).
	 * Exceptions are typically generated by the program.
	 * 
	 * Exceptions are of two types: checked (aka compile-time exceptions) [ex:
	 * FileNotFound, AWT, etc], and unchecked (aka runtime exceptions) [ex:
	 * NullPointer, ArrayIndexOutOfBounds, IllegalArgument, etc].
	 * 
	 * Convention: handle checked exceptions only. Handling unchecked exceptions is
	 * often impractical.
	 * 
	 *  // Prefer using standard Exceptions, instead of custom ones. 
	 */

	public static void throwingExceptions(int input) throws Exception {

		int acceptable = 15;
		if (input > acceptable) {
			throw new Exception();
		}
	}

	public static void catchingExceptions(String toRead, String toWrite) {
		/*
		 * Code that could potentially produce exceptions should always be enclosed in a
		 * try-catch block.
		 */

		try {
			// RISKY CODE.
			FileInputStream in = new FileInputStream(toRead);
			FileOutputStream out = new FileOutputStream(toWrite);

			out.write(in.read());

		} catch (IOException e) {
			/*
			 * Catch necessary exception(s) only, and order catch blocks based on
			 * most-specific to least-specific.
			 */
			System.out.println("IOExceptions");
			e.printStackTrace(); // Prints a trace of the error.

		} catch (Exception e) {
			System.out.println("All other exceptions");
			e.printStackTrace();
		}

		System.out.println("Code after the try-catch block");
	}

	public static void tryCatchFinally(String toRead, String toWrite) {

		try {
			FileInputStream in = new FileInputStream(toRead);
			FileOutputStream out = new FileOutputStream(toWrite);
			out.write(in.read());

			System.out.println("Executes if no exceptions are thrown by previous code.");

		} catch (IOException e) {
			System.out.println("Executes if exception is caught.");
			e.printStackTrace();
		} finally {
			System.out.println("Executes regardless of checked/unchecked exceptions.");
			/*
			 * finally blocks are often used to close resources {sub-classes that extend
			 * java.lang.AutoCloseable (typically IO classes)}, such that they can be
			 * garbage collected (improving memory usage).
			 * 
			 * Prefer using try-with-resources.
			 */
		}

		System.out.println("Executes if exception is handled.");
		// Does not execute in the case of unchecked exceptions.
	}

	public static void tryWithResources(String toRead, String toWrite) {

		// try (resource(s)) { }
		try (FileInputStream in = new FileInputStream(toRead); FileOutputStream out = new FileOutputStream(toWrite)) {
			/*
			 * Try-with-resources takes resources as arguments, and automatically closes the
			 * objects upon running through the method.
			 */
			out.write(in.read());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		// tryCatchFinally("", "");
	}
}
